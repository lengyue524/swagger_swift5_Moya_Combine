{{#operations}}// 
// {{classname}}.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation
import Alamofire
import OpenCombine
import Moya

enum {{classname}} {
{{#operation}}
    case {{operationId}}{{#allParams}}({{/allParams}}{{#allParams}}{{paramName}}: {{#isEnum}}{{#isContainer}}{{{dataType}}}{{/isContainer}}{{^isContainer}}{{{datatypeWithEnum}}}_{{operationId}}{{/isContainer}}{{/isEnum}}{{^isEnum}}{{{dataType}}}{{/isEnum}}{{^required}}? = nil{{/required}}{{#hasMore}}, {{/hasMore}}{{/allParams}}{{#allParams}}){{/allParams}}
{{/operation}}
}

extension {{classname}}: TargetType {
    var baseURL: URL {
        return URL(string: "/")!
    }

    var path: String {
        switch self {
        {{#operation}}
        case .{{operationId}}:
            return "{{{path}}}"
        {{/operation}}
        }
    }

    var method: Moya.Method {
        switch self {
        {{#operation}}
        case .{{operationId}}:
            return Alamofire.HTTPMethod(rawValue: "{{httpMethod}}")
        {{/operation}}
        }
    }

    var task: Moya.Task {
        switch self {
        {{#operation}}
        case .{{operationId}}{{#allParams}}({{/allParams}}{{#allParams}}{{paramName}}: let {{paramName}}{{#hasMore}}, {{/hasMore}}{{/allParams}}{{#allParams}}){{/allParams}}:
        {{#bodyParam}}
            return .uploadMultipart(FormDataHelper.encodingFormData(forEncodableObject: {{paramName}}) ?? [])
        {{/bodyParam}}
        {{#hasQueryParams}}
            let multipartData = [
                {{#allParams}}
                MultipartFormData(provider: .data({{paramName}}.data(using: .utf8)!), name: {{paramName}})
                {{/allParams}}
            ]
            return .uploadMultipart(multipartData)
        {{/hasQueryParams}}
        {{^allParams}}
            return .uploadMultipart([])
        {{/allParams}}
        {{/operation}}
        }
    }

    var headers: [String : String]? {
        return nil
    }
}

class DAuth{{classname}} {

    {{#operation}}
    /**
     {{#summary}}
     {{{summary}}}
     {{/summary}}{{#allParams}}
     - parameter {{paramName}}: ({{#isFormParam}}form{{/isFormParam}}{{#isQueryParam}}query{{/isQueryParam}}{{#isPathParam}}path{{/isPathParam}}{{#isHeaderParam}}header{{/isHeaderParam}}{{#isBodyParam}}body{{/isBodyParam}}) {{description}} {{^required}}(optional{{#defaultValue}}, default to {{{.}}}{{/defaultValue}}){{/required}}{{/allParams}}
     - returns: AnyPublisher<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}Void{{/returnType}}, ResponseError>
     */
    class func {{operationId}}({{#allParams}} {{paramName}}: {{#isEnum}}{{#isContainer}}{{{dataType}}}{{/isContainer}}{{^isContainer}}{{{datatypeWithEnum}}}_{{operationId}}{{/isContainer}}{{/isEnum}}{{^isEnum}}{{{dataType}}}{{/isEnum}}{{^required}}? = nil{{/required}}{{#hasMore}}, {{/hasMore}}{{/allParams}}) -> AnyPublisher<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}Void{{/returnType}}, ResponseError> {
        return Future<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}Void{{/returnType}}, ResponseError> { promise in
            DAuthAPI.provider().request(MultiTarget({{classname}}.{{operationId}}{{#allParams}}({{/allParams}}{{#allParams}} {{paramName}}: {{paramName}}{{#hasMore}}, {{/hasMore}}{{/allParams}}{{#allParams}}){{/allParams}})) { result in
                switch result {
                case let .success(res):
                    guard res.statusCode == 200 else {
                        promise(.failure(.HttpResponseError(res.statusCode, res.description)))
                        return
                    }
                    do {
                        let response = try JSONDecoder().decode(DAuthResponse<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}DAuthVoidData{{/returnType}}>.self, from: res.data)
                        if response.code != 0 {
                            promise(.failure(.ServerResponseError(response.code, response.message)))
                            return
                        }
                        {{#returnType}}
                        guard let data = response.data else {
                            promise(.failure(.ServerResponseError(DAUTH_SERVER_DATA_NULL, "\(#function)")))
                            return
                        }
                        promise(.success(data))
                        {{/returnType}}
                        {{^returnType}}
                        promise(.success(()))
                        {{/returnType}}
                    } catch {
                        promise(.failure(.JSONDecodeError(error)))
                    }
                case let .failure(error):
                    promise(.failure(.ConnectionError(error)))
                }
                
            }
        }.eraseToAnyPublisher()
    }
    
    {{/operation}}
}
{{/operations}}